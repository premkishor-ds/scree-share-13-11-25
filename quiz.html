<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Screen Quiz Recorder</title>
<style>
body {
font-family: Arial, sans-serif;
margin: 2rem auto;
max-width: 720px;
line-height: 1.5;
}
h1, h2 {
margin-bottom: 0.5rem;
}
section {
margin-bottom: 1.5rem;
}
button {
margin-right: 0.5rem;
padding: 0.5rem 1rem;
font-size: 1rem;
}
.options button {
display: block;
width: 100%;
margin: 0.5rem 0;
text-align: left;
}
.hidden {
display: none;
}
#recordingPreview {
width: 100%;
max-height: 360px;
margin-top: 0.5rem;
}
</style>
</head>
<body>
<h1>Interactive Quiz</h1>
<p>
Start the quiz to begin screen recording. When you stop the quiz, the recording will
download locally, upload to the server, and appear below.
</p>

<section>
<button id="startQuiz">Start Quiz</button>
<button id="stopQuiz" disabled>Stop Quiz</button>
</section>

<section id="quizContainer" class="hidden">
<h2>Question <span id="questionNumber"></span></h2>
<p id="questionText"></p>
<div id="options" class="options"></div>
<p id="feedback"></p>
</section>

<section>
<h2>Status</h2>
<p id="statusMessage">Waiting to start quiz.</p>
</section>

<section id="recordingSection" class="hidden">
<h2>Recording</h2>
<video id="recordingPreview" controls></video>
<p>
Download: <a id="recordingDownloadLink" href="#">(link)</a><br />
View online: <a id="recordingUrlLink" href="#" target="_blank" rel="noopener">(link)</a>
</p>
</section>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const peers = {};
const startQuizBtn = document.getElementById('startQuiz');
const stopQuizBtn = document.getElementById('stopQuiz');
const quizContainer = document.getElementById('quizContainer');
const questionNumber = document.getElementById('questionNumber');
const questionText = document.getElementById('questionText');
const optionsEl = document.getElementById('options');
const feedbackEl = document.getElementById('feedback');
const statusMessage = document.getElementById('statusMessage');
const recordingSection = document.getElementById('recordingSection');
const recordingPreview = document.getElementById('recordingPreview');
const downloadLink = document.getElementById('recordingDownloadLink');
const recordingUrlLink = document.getElementById('recordingUrlLink');

const quizQuestions = [
{
question: 'Which JavaScript method is used to add a new element to an array?',
options: ['append()', 'push()', 'add()', 'insert()'],
answerIndex: 1,
},
{
question: 'What keyword declares a constant in modern JavaScript?',
options: ['constant', 'let', 'var', 'const'],
answerIndex: 3,
},
{
question: 'Which HTTP method is typically used to retrieve data?',
options: ['POST', 'PUT', 'GET', 'PATCH'],
answerIndex: 2,
},
];

let currentQuestion = 0;
let localStream = null;
let mediaRecorder = null;
let recordedChunks = [];
let recordingSaved = false;
let isBroadcasting = false;
let recordingResultSent = false;

startQuizBtn.addEventListener('click', startQuiz);
stopQuizBtn.addEventListener('click', stopQuiz);

async function startQuiz() {
startQuizBtn.disabled = true;
statusMessage.textContent = 'Requesting screen capture...';

try {
localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
} catch (err) {
statusMessage.textContent = 'Screen capture permission denied or unavailable: ' + err.message;
startQuizBtn.disabled = false;
return;
}

const [videoTrack] = localStream.getVideoTracks();
if (videoTrack) {
videoTrack.addEventListener('ended', () => stopQuiz('Screen capture stopped by user.'));
}

if (!startRecording()) {
statusMessage.textContent = 'Screen captured without recording support.';
} else {
statusMessage.textContent = 'Quiz started. Recording in progress.';
}

isBroadcasting = true;
recordingResultSent = false;
socket.emit('broadcaster');

stopQuizBtn.disabled = false;
quizContainer.classList.remove('hidden');
recordingSection.classList.add('hidden');
resetRecordingLinks();
recordingSaved = false;
currentQuestion = 0;
renderQuestion();
}

function stopQuiz(message) {
if (stopQuizBtn.disabled) {
return;
}

isBroadcasting = false;
stopQuizBtn.disabled = true;
startQuizBtn.disabled = false;
quizContainer.classList.add('hidden');
feedbackEl.textContent = '';

socket.emit('stop-broadcast');
if (!mediaRecorder && !recordingResultSent) {
socket.emit('recording-ready', { fileUrl: null });
recordingResultSent = true;
}

Object.keys(peers).forEach(closePeer);

if (localStream) {
localStream.getTracks().forEach(track => track.stop());
localStream = null;
}

if (mediaRecorder && mediaRecorder.state !== 'inactive') {
mediaRecorder.stop();
} else if (!recordingSaved) {
statusMessage.textContent = message || 'Quiz finished.';
notifyRecordingUnavailable();
}

statusMessage.textContent = message || 'Quiz finished. Processing recording...';
}

function renderQuestion() {
if (currentQuestion >= quizQuestions.length) {
feedbackEl.textContent = 'Quiz complete!';
stopQuiz('Quiz completed.');
return;
}

const { question, options, answerIndex } = quizQuestions[currentQuestion];
questionNumber.textContent = currentQuestion + 1;
questionText.textContent = question;
feedbackEl.textContent = '';

optionsEl.innerHTML = '';
options.forEach((optionText, idx) => {
const btn = document.createElement('button');
btn.type = 'button';
btn.textContent = optionText;
btn.addEventListener('click', () => {
if (idx === answerIndex) {
feedbackEl.textContent = 'Correct!';
currentQuestion += 1;
setTimeout(renderQuestion, 800);
} else {
feedbackEl.textContent = 'Try again.';
}
});
optionsEl.appendChild(btn);
});
}

function startRecording() {
recordedChunks = [];
mediaRecorder = null;

if (!localStream || typeof MediaRecorder === 'undefined') {
return false;
}

const mimeTypes = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
for (const type of mimeTypes) {
if (MediaRecorder.isTypeSupported ? MediaRecorder.isTypeSupported(type) : true) {
try {
mediaRecorder = new MediaRecorder(localStream, { mimeType: type });
break;
} catch (err) {
console.warn('Failed to start MediaRecorder with type', type, err);
}
}
}

if (!mediaRecorder) {
return false;
}

mediaRecorder.ondataavailable = event => {
if (event.data && event.data.size) {
recordedChunks.push(event.data);
}
};

mediaRecorder.onstop = () => {
const chunks = recordedChunks.slice();
recordedChunks = [];

if (!chunks.length) {
statusMessage.textContent = 'Quiz finished. No recording captured.';
notifyRecordingUnavailable();
if (!recordingResultSent) {
socket.emit('recording-ready', { fileUrl: null });
recordingResultSent = true;
}
return;
}

const blob = new Blob(chunks, { type: 'video/webm' });
const fileName = `quiz-recording-${Date.now()}.webm`;

triggerDownload(blob, fileName);
uploadRecording(blob, fileName)
.then(({ fileUrl }) => {
statusMessage.textContent = 'Recording saved. Links below.';
showRecording(blob, fileName, fileUrl);
socket.emit('recording-ready', { fileUrl });
recordingResultSent = true;
})
.catch(err => {
console.error('Upload failed:', err);
statusMessage.textContent = 'Recording upload failed: ' + err.message;
showRecording(blob, fileName, null);
if (!recordingResultSent) {
socket.emit('recording-ready', { fileUrl: null });
recordingResultSent = true;
}
});
};

mediaRecorder.start(1000);
return true;
}

function triggerDownload(blob, fileName) {
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = fileName;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
setTimeout(() => URL.revokeObjectURL(url), 0);
}

function showRecording(blob, fileName, fileUrl) {
const localUrl = URL.createObjectURL(blob);
recordingPreview.src = localUrl;
recordingPreview.load();
recordingSection.classList.remove('hidden');

downloadLink.href = localUrl;
downloadLink.download = fileName;
downloadLink.textContent = fileName;

if (fileUrl) {
recordingUrlLink.href = fileUrl;
recordingUrlLink.textContent = fileUrl;
recordingUrlLink.removeAttribute('aria-disabled');
} else {
recordingUrlLink.href = '#';
recordingUrlLink.textContent = 'Unavailable';
recordingUrlLink.setAttribute('aria-disabled', 'true');
}

recordingSaved = true;
setTimeout(() => URL.revokeObjectURL(localUrl), 60000);
}

function notifyRecordingUnavailable() {
recordingSection.classList.remove('hidden');
recordingPreview.removeAttribute('src');
recordingPreview.load();
downloadLink.href = '#';
downloadLink.textContent = 'No recording captured';
recordingUrlLink.href = '#';
recordingUrlLink.textContent = 'No recording stored on server';
recordingUrlLink.setAttribute('aria-disabled', 'true');
recordingSaved = true;
}

async function uploadRecording(blob, fileName) {
const formData = new FormData();
formData.append('recording', blob, fileName);

const response = await fetch('/api/recordings', {
method: 'POST',
body: formData,
});

if (!response.ok) {
const text = await response.text();
throw new Error(text || 'Failed to upload recording.');
}

return response.json();
}

function resetRecordingLinks() {
recordingPreview.removeAttribute('src');
recordingPreview.load();
downloadLink.href = '#';
downloadLink.removeAttribute('download');
downloadLink.textContent = '(link)';
recordingUrlLink.href = '#';
recordingUrlLink.textContent = '(link)';
recordingUrlLink.setAttribute('aria-disabled', 'true');
}

socket.on('watcher', handleWatcher);
socket.on('answer', (watcherId, description) => {
const pc = peers[watcherId];
if (pc) {
pc.setRemoteDescription(description).catch(console.error);
}
});

socket.on('candidate', (id, candidate) => {
const pc = peers[id];
if (pc) {
pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}
});

socket.on('disconnectPeer', closePeer);

socket.on('broadcaster-stopped', () => {
if (!isBroadcasting) {
statusMessage.textContent = 'Broadcast stopped.';
}
});

async function handleWatcher(watcherId) {
if (!localStream) {
return;
}

const pc = new RTCPeerConnection();
peers[watcherId] = pc;

localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

pc.onicecandidate = event => {
if (event.candidate) {
socket.emit('candidate', watcherId, event.candidate);
}
};

pc.oniceconnectionstatechange = () => {
if (['disconnected', 'failed', 'closed'].includes(pc.iceConnectionState)) {
closePeer(watcherId);
}
};

const offer = await pc.createOffer();
await pc.setLocalDescription(offer);
socket.emit('offer', watcherId, pc.localDescription);
}

function closePeer(id) {
const pc = peers[id];
if (pc) {
pc.close();
delete peers[id];
}
}
</script>
</body>
</html>

